(defpackage :icfp/simulator
  (:nicknames :simulator)
  (:use :cl :alexandria :cl-json :icfp/state :icfp/gui :icfp/tetris)
  (:export :play :gen-simulator :play-move))

(in-package :icfp/simulator)

(defvar *last-log*)
(defvar *score*)
(defvar *last-bonus*)
(defvar *last-clear-no*)
(defvar *last-clear-lines*)
(defvar *curr-unit-no*)

(defun read-simulation (file)
  (with-open-file (problem file)
    (json:decode-json problem)))

(defun play (file result-num)
  (let* ((result (nth result-num (read-simulation file))))
    (solve-problem (get-item :problem-id result)
		   :solver (gen-simulator (lambda (board)
					    (read-cmds board (get-item :solution result) 0))
					  :filter-seed (get-item :seed result))
		   :with-gui t)))

(defun gen-simulator (solver &key filter-seed)
  (lambda (id seed board with-gui)
    (declare (ignore id with-gui))
    (let ((*last-log* nil)
	  (*score* 0)
	  (*last-bonus* 0)
	  (*last-clear-no* -100)
	  (*last-clear-lines* 0)
	  (*curr-unit-no* 0))
      (when (or (not filter-seed) (eql seed filter-seed))
	(run-gui board (lambda () (funcall solver board)))))))

(defun decode-move (solution index)
  (let ((move-code (aref solution index)))
    (cond
      ((find move-code "p'!.03P") (values :W (1+ index)))
      ((find move-code "becfy2BECFY") (values :E (1+ index)))
      ((find move-code "aghij4AGHIJ") (values :SW (1+ index)))
      ((find move-code "lmno 5LMNO") (values :SE (1+ index)))
      ((find move-code "dqrvz1DQRVZ") (values :R+ (1+ index)))
      ((find move-code "kstuwxKSTUWX") (values :R- (1+ index)))
      ((find move-code (list #\Tab #\Linefeed #\Return)) (decode-move solution (1+ index)))
      (t (error "Unknown move ~A" move-code)))))

(defun read-cmds (board solution index)  
  (multiple-value-bind (move next-index) (decode-move solution index)    
    (read-cmds (play-move board move) solution next-index)))

(defun play-move (board move)
  (update-gui board)
  (let* ((next-board (make-move board move))
	 (log (board-log next-board)))
    (when (and log (not (eq log *last-log*)))
      (setf *last-log* log)
      (incf *curr-unit-no*)
      (let* ((score-entry (first log))
	     (clear-bonus (* 50 (1+ (score-lines score-entry)) (score-lines score-entry)))
	     (points (+ (score-size score-entry) clear-bonus))
	     (line-bonus (if (and (not (zerop clear-bonus))
				  (eql *last-clear-no* (1- *curr-unit-no*)))
			     (floor (* (+ points *score*) (1- *last-clear-lines*) 0.1))
			     0)))
	(unless (zerop clear-bonus)
	  (setf *last-clear-no* *curr-unit-no*
		*last-clear-lines* (score-lines score-entry)
		*last-bonus* (+ line-bonus clear-bonus)))
	(incf *score* (+ points line-bonus)))
      (with-simple-restart (continue-processing "Continue?")
	(signal 'board-update :debug-msg (format nil "Placed: ~3D     Score: ~D     Last bonus: ~D" *curr-unit-no* *score* *last-bonus*))))
    next-board))
